package com.airfranceklm.amt.sidecar.model.alcp;

import javax.crypto.EncryptedPrivateKeyInfo;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

/**
 * Helper class for frequent operations with RSA keys, which simplifies loading the public and private keys
 * as they have been generated by the OpenSSL library.
 */
public class RSAKeyOps {
    public static final Base64.Decoder decoder = Base64.getDecoder();

    public static RSAPublicKey publicKeyFromPCKS8(String str) throws IOException, InvalidKeySpecException {
        try (ByteArrayInputStream bais = new ByteArrayInputStream(str.getBytes())) {
          return publicKeyFromPCKS8(bais);
        }
    }

    public static RSAPublicKey publicKeyFromPCKS8(InputStream is) throws IOException, InvalidKeySpecException {
        if (is == null) {
            return null;
        }

        X509EncodedKeySpec spec =
                new X509EncodedKeySpec(decodeMultilineBase64(stripPEMTags(textOf(is))));

        try {
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return (RSAPublicKey)kf.generatePublic(spec);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("RSA algorithm must be supported by the JVM");
        }
    }

    public static RSAPrivateKey privateKeyFromPKCS8(String base64, String pwd) throws IOException, InvalidKeyException, InvalidKeySpecException {
        try (ByteArrayInputStream bais = new ByteArrayInputStream(base64.getBytes())) {
            return privateKeyFromPKCS8(bais, pwd);
        }
    }

    public static RSAPrivateKey privateKeyFromPKCS8(InputStream is, String pwd) throws IOException, InvalidKeySpecException, InvalidKeyException {
        if (is == null) {
            return null;
        }

        final byte[] keyMaterial = decodeMultilineBase64(stripPEMTags(textOf(is)));

        EncryptedPrivateKeyInfo encSpec = new EncryptedPrivateKeyInfo(keyMaterial);
        PBEKeySpec encPass = new PBEKeySpec(pwd.toCharArray());

        try {
            SecretKeyFactory skf = SecretKeyFactory.getInstance(encSpec.getAlgName());
            PKCS8EncodedKeySpec keySpec = encSpec.getKeySpec(skf.generateSecret(encPass));

            return (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(keySpec);
        } catch (NoSuchAlgorithmException ex) {
            throw new IllegalStateException("RSA algorithm must be supported by the hosting JVM");
        }
    }

    private static String textOf(InputStream is) throws IOException {
        final int inSize = is.available();

        ByteArrayOutputStream baos = new ByteArrayOutputStream(inSize);
        byte[] buf = new byte[Math.max(1024, inSize)];

        int k = 0;
        while ((k = is.read(buf)) > 0) {
            baos.write(buf, 0, k);
        }

        return baos.toString();
    }

    public static String pemAsString(String str) {
        return removeMultiline(stripPEMTags(str));
    }

    private static byte[] decodeMultilineBase64(String rawBase64) {
        if (rawBase64 != null) {
            return decoder.decode(removeMultiline(rawBase64));
        } else {
            return null;
        }
    }

    private static String removeMultiline(String rawBase64) {
        return rawBase64.replaceAll("(?m)^[ \\t]*\\r?\\n", "") // Remove multi-line empty strings
                        .replaceAll("\\r?\\n", "");
    }

    private static String stripPEMTags(String str) {
        return str.replaceAll("-----[A-Z ]*-----", "");
    }
}
