Including Application EAVs:
  desc: Check that the ApplicationEAVs are included.

  endpoint:
    service id: srvId
    endpoint id: endpId
    endpoint name: unit-test-endpoint
    endpoint uri: https://api-unitttest.airfranceklm.com/api-path

    pre-processor configuration:
      require-eavs: PkA
      include-eavs: PkB,PkC
      expand-input: +requestHeaders

  cases:
    sending correct message with PkC missing:
      client:
        remote address: 123.456.789.012
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr
        headers:
          A: B
        body: ABC

      key:
        package key: dfgf
        application:
          name: the-app
          extended attributes:
            PkA: PkA-Value
            PkB: PkB-Value


      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId
          eavs:
            PkA: PkA-Value
            PkB: PkB-Value

        output:
        # An empty object, do nothing.

    send 400 when required eav being empty:
      desc: with the package key being empty, the 400 message should be sent back.
      client:
        as in: sending correct message with PkC missing

      key:
        package key: dfgf
        application:
          name: the-app
          extended attributes:
            PkA: "      "
            PkB: PkB-Value
            PkC: PkC-Value

      request to the api provider:
        as in: sending correct message with PkC missing

      expect traffic manager:
        set complete: true
        status code: 400
        headers:
          content-type: application/xml
        body: "<h1><![CDATA[Request pre-condition not met, code 0x000003BB]]></h1>"


    send 400 when required eav is null:
      desc: with the package key being empty, the 400 message should be sent back.
      client:
        as in: sending correct message with PkC missing

      key:
        package key: dfgf
        application:
          name: the-app
          extended attributes:
            PkB: PkB-Value
            PkC: PkC-Value

      request to the api provider:
        as in: sending correct message with PkC missing

      expect traffic manager:
        as in: send 400 when required eav being empty

Including Package Key EAVs:
  desc: Check that the package key ApplicationEAVs are included.

  endpoint:
    service id: srvId
    endpoint id: endpId
    endpoint name: unit-test-endpoint
    endpoint uri: https://api-unitttest.airfranceklm.com/api-path

    pre-processor configuration:
      require-packageKey-eavs: PkA
      include-packageKey-eavs: PkB,PkC
      expand-input: "+requestHeaders"

  cases:
    sending correct message with PkC missing:
      client:
        remote address: 123.456.789.012
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr
        headers:
          A: B
        body: ABC

      key:
        package key: dfgf
        extended attributes:
          PkA: PkA-Value
          PkB: PkB-Value
        application:
          name: the-app

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId
          packageKeyEAVs:
            PkA: PkA-Value
            PkB: PkB-Value

        output:
        # An empty object, do nothing.

    send 400 when required package key being empty:
      desc: with the package key being empty, the 400 message should be sent back.
      client:
        as in: sending correct message with PkC missing

      key:
        package key: dfgf
        extended attributes:
          PkA: "      "
          PkB: PkB-Value
          PkC: PkC-Value
        application:
          name: the-app

      request to the api provider:
        as in: sending correct message with PkC missing

      expect traffic manager:
        set complete: true
        status code: 400
        headers:
          content-type: application/xml
        body: "<h1><![CDATA[Request pre-condition not met, code 0x000003BB]]></h1>"


    send 400 when required package key is null:
      desc: with the package key being empty, the 400 message should be sent back.
      client:
        as in: sending correct message with PkC missing

      key:
        package key: dfgf
        extended attributes:
          PkB: PkB-Value
          PkC: PkC-Value
        application:
          name: the-app

      request to the api provider:
        as in: sending correct message with PkC missing

      expect traffic manager:
        as in: send 400 when required package key being empty


Routing data expansion:
  desc: Checks that the rouiting data is expanded correctly

  endpoint:
    service id: srvId
    endpoint id: endpId
    endpoint name: unit-test-endpoint
    endpoint uri: https://api-unitttest.airfranceklm.com/api-path

    pre-processor configuration:
      expand-input: routing,+requestHeaders

  cases:
    expansion of routing:
      client:
        remote address: 123.456.789.012
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr
        headers:
          A: B
        body: ABC

      key:
        package key: dfgf
        application:
          name: the-app

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId
          routing:
            httpVerb: POST
            uri: https://docker.kml/backend/url?myQuery=ffff

        output:
        # An empty object, do nothing.]]



Token data expansion:
  desc: Checks that the token data is expanded correctly

  endpoint:
    service id: srvId
    endpoint id: endpId
    endpoint name: unit-test-endpoint
    endpoint uri: https://api-unitttest.airfranceklm.com/api-path

    pre-processor configuration:
      expand-input: token,+requestHeaders

  cases:
    expansion of token:
      client:
        remote address: 123.456.789.012
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr
        headers:
          A: B
        body: ABC

      key:
        package key: dfgf
        application:
          name: the-app

      authorization context:
        scope: "12345"
        user context: "456"
        grant type: CC
        expires: "2020-03-24T13:48:09Z"

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId
          token:
            scope: "12345"
            userContext: "456"
            grantType: CC
            expires: "2020-03-24T13:48:09Z"

        output:
        # An empty object, do nothing.]]

    expansion with token data missing:
      client:
        as in: expansion of token
      key:
        as in: expansion of token

      request to the api provider:
        as in: expansion of token

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId

        output:
        # An empty object, do nothing.

Remote Address expansion:
  desc: Checking that the remote address will be passed correctly.

  endpoint:
    service id: srvId
    endpoint id: endpId
    endpoint name: unit-test-endpoint
    endpoint uri: https://api-unitttest.airfranceklm.com/api-path

    pre-processor configuration:
      expand-input: remoteAddress,+requestHeaders

  cases:
    correct remote addr attribution:
      client:
        remote address: 123.456.789.012
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr
        headers:
          A: B
        payload: ABC

      key:
        package key: dfgf
        application:
          name: the-app

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId
          remoteAddress: 123.456.789.012

        output:
        # An empty object, do nothing.

Operation expansion test:
  desc: Checking that the function parameters will be passed.

  endpoint:
    service id: srvId
    endpoint id: endpId
    endpoint name: unit-test-endpoint
    endpoint uri: https://api-unitttest.airfranceklm.com/api-path

    pre-processor configuration:
      expand-input: operation,+requestHeaders

  cases:
    correct extraction:
      client:
        remote address: 127.0.0.1
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr
        headers:
          A: B
        payload: ABC

      key:
        package key: dfgf
        application:
          name: the-app

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId
          operation:
            httpVerb: POST
            path: /path/to/op
            query:
              myQuery: "123"
              p1: djfr

            uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr

        output:
        # An empty object, do nothing.

    correct extraction without query string:
      client:
        remote address: 127.0.0.1
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op
        headers:
          A: B
        payload: ABC

      key:
        as in: correct extraction

      request to the api provider:
        as in: correct extraction

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: srvId
          endpointId: endpId
          operation:
            httpVerb: POST
            path: /path/to/op
            uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op

      output:
      # An empty object, do nothing.

Passing parameters test:
  desc: Checking that the function parameters will be passed.

  endpoint:
    service id: fff
    endpoint id: ffff
    endpoint name: fake

    pre-processor configuration:
      sidecar-param-p1: value-1
      sidecar-param-p2: value-2
      expand-input: +requestHeaders

  cases:
    positively passing:
      client:
        remote address: 127.0.0.1
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/api-path/path/to/op?myQuery=123&p1=djfr
        headers:
          A: B
        payload: ABC

      key:
        package key: dfgf
        application:
          name: the-app

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: Event
          point: PreProcessor
          params:
            p1: value-1
            p2: value-2

          request:
            headers:
              a: B
          packageKey: dfgf
          serviceId: fff
          endpointId: ffff

        output:
          # An empty object, do nothing.

Max Request Size Blocking Configuration:
  desc: Checks that the maximum size for the payload is honoured.

  endpoint:
    service id: fff
    endpoint id: ffff
    endpoint name: fake

    pre-processor configuration:
      synchronicity: request-response
      # We have to request the expansion of the input into the payload
      # in order for the payload limiting to kick-in.
      expand-input: requestPayload,+requestHeaders
      max-payload-size: 5b,blocking

  cases:
    fitting payload:
      client:
        remote address: 127.0.0.1
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/fff?myQuery=123
        headers:
          a: B
        payload: ABC

      key:
        package key: dfgf
        application:
          name: the-app

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
            payload: ABC
          packageKey: dfgf
          serviceId: fff
          endpointId: ffff

        output:
            # An empty object, do nothing.

        # Te request should go through without any further modifications.

    exceeding payload:
      client:
        remote address: 127.0.0.1
        http verb: POST
        uri: https://api-unitttest.airfranceklm.com/fff?myQuery=123
        headers:
          a: B
        payload: ABCDEFGHIJKLMOP



      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff

      # Lambda function is not called: the 400 will be returned back
      # to the calling application.

      expect traffic manager:
        set complete: true
        status code: 400
        headers:
          content-type: application/xml
        body: "<h1><![CDATA[Request pre-condition not met, code 0x000003BB]]></h1>"


Smoke Test:
  desc: This is a simple test simulation

  endpoint:
    service id: fff
    endpont id: ffff
    endpoint name: fake

    pre-processor configuration:
      synchronicity: request-response
      expand-input: +requestHeaders

    post-processor configuration:

  cases:
    base rejection scenario:
      event: pre-processor
      desc: Checking that the unit test will compile and will nominally pass.

      client:
        remote address: 127.0.0.1
        http verb: GET
        uri: https://api-unitttest.airfranceklm.com/fff?myQuery=123
        headers:
          A: B
          C: C1
        payload: AAAA
        # RequestPayload can be for GET-type requests.

      key:
        package key: dfgf
        application:
          name: the-app
          extended attributes:
            a: b

      authorization context:
        scope: "12345"
        user context: "456"
        grant type: CC

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff
        dropped headers:
          - C
          - D
        added headers:
          E: F
          G: H

      # This is what should be sent to lambda
      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
              e: F
              g: H

          packageKey: dfgf
          serviceId: fff
          endpontId: ffff

        output:
          code: 403
          message: "Lambda 403"


      expect traffic manager:
        set complete: true
        status code: 403
        headers:
          content-type: application/xml
        body: "<h1><![CDATA[Lambda 403]]></h1>"

    rejection with single code:
      event: pre-processor
      desc: Checking that the unit test will compile and will nominally pass.

      client:
        as in: base rejection scenario

      key:
        as in: base rejection scenario

      authorization context:
        as in: base rejection scenario

      request to the api provider:
        as in: base rejection scenario

      # This is what should be sent to lambda
      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
              e: F
              g: H

          packageKey: dfgf
          serviceId: fff
          endpontId: ffff

        output:
          code: 403
          # Message is not provided


      expect traffic manager:
        set complete: true
        status code: 403
        headers:
          content-type: application/xml
        body: "<h1><![CDATA[Service cannot be provided, code 0x000003BB]]></h1>"

    rejection with payload:
      event: pre-processor
      desc: Checking that the unit test will compile and will nominally pass.

      client:
        as in: base rejection scenario

      key:
        as in: base rejection scenario

      authorization context:
        as in: base rejection scenario

      request to the api provider:
        as in: base rejection scenario

      # This is what should be sent to lambda
      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
              e: F
              g: H

          packageKey: dfgf
          serviceId: fff
          endpontId: ffff

        output:
          code: 403
          addHeaders:
            X-sidecar: Error
          payload: "==PAYLOAD=="
          # Message is not provided


      expect traffic manager:
        set complete: true
        status code: 403
        headers:
          X-sidecar: Error
        body: "==PAYLOAD=="

    rejection with json and content type:
      event: pre-processor
      desc: Checking that the unit test will compile and will nominally pass.

      client:
        as in: base rejection scenario

      key:
        as in: base rejection scenario

      authorization context:
        as in: base rejection scenario

      request to the api provider:
        as in: base rejection scenario

      # This is what should be sent to lambda
      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
              e: F
              g: H

          packageKey: dfgf
          serviceId: fff
          endpontId: ffff

        output:
          code: 403
          addHeaders:
            content-type: application/json+hal
          json:
            a: b
          # Message is not provided


      expect traffic manager:
        set complete: true
        status code: 403
        headers:
          content-type: application/json+hal
          content-encoding: "gzip"
        body: "H4sIAAAAAAAAAKtWSlSyUkpSqgUAnFz2awkAAAA="

    rejection with json and without content type:
      event: pre-processor
      desc: Checking that the unit test will compile and will nominally pass.

      client:
        as in: base rejection scenario

      key:
        as in: base rejection scenario

      authorization context:
        as in: base rejection scenario

      request to the api provider:
        as in: base rejection scenario

      # This is what should be sent to lambda
      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
              e: F
              g: H

          packageKey: dfgf
          serviceId: fff
          endpontId: ffff

        output:
          code: 403
          addHeaders:
            x-sidecar: super
          json:
            a: b
          # Message is not provided


      expect traffic manager:
        set complete: true
        status code: 403
        headers:
          x-sidecar: super
          content-type: application/json
          content-encoding: "gzip"
        body: "H4sIAAAAAAAAAKtWSlSyUkpSqgUAnFz2awkAAAA="


    error reporting on internal problem:
      event: pre-processor
      desc: Checking that the unit test will compile and will nominally pass.

      client:
        as in: base rejection scenario

      key:
        as in: base rejection scenario

      authorization context:
        as in: base rejection scenario

      request to the api provider:
        as in: base rejection scenario

      # This is what should be sent to lambda
      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
              e: F
              g: H

          packageKey: dfgf
          serviceId: fff
          endpontId: ffff

        throw error: "Lambda has failed"


      expect traffic manager:
        set complete: true
        status code: 500
        headers:
          content-type: application/xml
        body: "<h1><![CDATA[Internal server error before processing the call, code 0x000003BB]]></h1>"



Fail-safe configuration cases:
  desc: This is a simple test simulation

  endpoint:
    service id: fff
    endpont id: ffff
    endpoint name: fake

    pre-processor configuration:
      synchronicity: request-response
      expand-input: +requestHeaders
      failsafe: "true"

    post-processor configuration:
      c: d

  cases:

    continues on receiving internal error:
      event: pre-processor
      desc: Checking that the unit test will compile and will nominally pass.

      client:
        remote address: 127.0.0.1
        http verb: GET
        uri: https://api-unitttest.airfranceklm.com/fff?myQuery=123
        headers:
          A: B
          C: C1
        body: AAAA
          # RequestPayload can be for GET-type requests.

      key:
        package key: dfgf
        application:
          name: the-app
          extended attributes:
            a: b

      authorization context:
        scope: "12345"
        user context: "456"
        grant type: CC

      request to the api provider:
        provider uri: https://docker.kml/backend/url?myQuery=ffff
        dropped headers:
          - C
          - D
        added headers:
          E: F
          G: H

      # This is what should be sent to lambda
      sidecar:
        input:
          synchronicity: RequestResponse
          point: PreProcessor
          request:
            headers:
              a: B
              e: F
              g: H

          packageKey: dfgf
          serviceId: fff
          endpontId: ffff

        throw error: "Lambda has failed"


      # Failure of the lambda function doesn't stop.
